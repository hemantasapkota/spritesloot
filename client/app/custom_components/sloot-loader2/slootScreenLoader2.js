/*Laexian Box2D Loader.
  Given the JSON model generated by Laexian Box2D Editor; and Box2D World, this
  class creates Box2D bodies and notifies when done. 
  Hemanta Sapkota.
*/

var   
   b2Vec2 = Box2D.Common.Math.b2Vec2
,  b2AABB = Box2D.Collision.b2AABB
,  b2BodyDef = Box2D.Dynamics.b2BodyDef
,  b2Body = Box2D.Dynamics.b2Body
,  b2FixtureDef = Box2D.Dynamics.b2FixtureDef
,  b2FilterData = Box2D.Dynamics.b2FilterData
,  b2Fixture = Box2D.Dynamics.b2Fixture
,  b2World = Box2D.Dynamics.b2World
,  b2MassData = Box2D.Collision.Shapes.b2MassData
,  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
,  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
,  b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
,  b2DebugDraw = Box2D.Dynamics.b2DebugDraw
,  b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
,  b2Color = Box2D.Common.b2Color


var b2World = null;
var ptmRatio = 16; //defualt 16

function slootScreenLoader2(cgScreenModel, world) {

	ptmRatio = cgScreenModel.screenPrefs.worldPrefs.ptmRatio;
	cardHeight = cgScreenModel.screenPrefs.cardPrefs.cardHeight;
	b2World = world;

	slootScreenLoader2.prototype.CreateShape = function(onFixtureCreated) {

    $.each(cgScreenModel, function(index, value) {

         if (index != "layers")
            return;

         var layers = value;

         $.each(layers, function(layerIndex, layer) {

            $.each(layer.shape, function(shapeIndex, shape) {

               var returnObject = {};

               returnObject.shape = shape;

               slootScreenLoader2.prototype.CreateBody( shape, returnObject, onFixtureCreated );

            });

         });

       });	
	}

	//Create bodies and joints
	slootScreenLoader2.prototype.CreateBody = function( shape, returnObject, onFixtureCreated ) {
	  var bodyDef = new b2BodyDef;
	  var fixtureDef = new b2FixtureDef;

	  //Body Def
	  bodyDef.active = shape.bodyDef.active;
	  bodyDef.allowSleep = shape.bodyDef.allowSleep;
	  bodyDef.angle = shape.bodyDef.angle;
	  bodyDef.angularDamping = shape.bodyDef.angularDamping;
	  bodyDef.angularVelocity = shape.bodyDef.angularVelocity;
	  bodyDef.awake = shape.bodyDef.awake;
	  bodyDef.bullet = shape.bodyDef.bullet;
	  bodyDef.fixedRotation = shape.bodyDef.fixedRotation;
	  bodyDef.inertialScale = shape.bodyDef.inertialScale;
	  bodyDef.linearDamping = shape.bodyDef.linearDamping;
	  bodyDef.gravityScale = shape.bodyDef.gravityScale;

	  bodyDef.linearVelocity = slootScreenLoader2.prototype.AsVec2(shape.bodyDef.linearVelocity);
	  bodyDef.type = slootScreenLoader2.prototype.AsBodyType(shape.bodyDef.type);
	  bodyDef.position = slootScreenLoader2.prototype.AsVec2(shape.bodyDef.position);

	  fixtureDef = slootScreenLoader2.prototype.AsFixtureDef(shape.fixtureDef)

	  returnObject.fixtures = [];

	  switch (shape.editorShapeType) {
	     case "SIMPLE_SHAPE_BOX":
	     var bb = new boxBody;
	     bb.Create( shape, bodyDef, fixtureDef, returnObject, onFixtureCreated );
	     break;

	     case "SIMPLE_SHAPE_CIRCLE":
	     var cb = new circleBody;
	     cb.Create( shape, bodyDef, fixtureDef, returnObject, onFixtureCreated );
	     break;

	     case "SIMPLE_SHAPE_HEDGE":
	     case "SIMPLE_SHAPE_VEDGE":
	     var edb = new edgeBody;
	     edb.Create( shape, bodyDef, fixtureDef, returnObject, onFixtureCreated );
	     break;

	     case "ENTITY_SHAPE":
	     var entBody = new entityBody;
	     entBody.Create( shape, bodyDef, fixtureDef, returnObject, onFixtureCreated );
	     break;

	     default:
	  }

	}  

	//world/screen transformation
	slootScreenLoader2.prototype.ScreenToWorldFlipped = function(screenCoords, shapeHeight) {
	  var newVec = new b2Vec2;
	  newVec.x = screenCoords.x / ptmRatio;
	  newVec.y = (cardHeight - shapeHeight - screenCoords.y) / ptmRatio;

	  return newVec;
	}

	slootScreenLoader2.prototype.ScreenToWorld = function( screenCoords ) {
	  var newVec = new b2Vec2;
	  newVec.x = screenCoords.x / ptmRatio;
	  newVec.y = screenCoords.y  / ptmRatio;

	  return newVec;
	}  

	slootScreenLoader2.prototype.CalculateRadiusOfCirlce = function( width ) {
	  return (width / ptmRatio) / 2;
	}

	//Protobuf type conversion util
	slootScreenLoader2.prototype.AsBodyType = function( type ) {
	  if (type == "DYNAMIC")
	     return b2Body.b2_dynamicBody;

	  if (type == "KINEMATIC")
	     return b2Body.b2_kinematicBody;

	  //default
	  return b2Body.b2_staticBody;
	}

	slootScreenLoader2.prototype.AsVec2 = function( v ) {
	  var v2 = new b2Vec2;

	  v2.x = v.x;
	  v2.y = v.y;

	  return v2;
	}

	slootScreenLoader2.prototype.AsFixtureDef = function( defFix, shapeType ) {
	  var fixtureDef = new b2FixtureDef;

	  fixtureDef.density = defFix.density;
	  fixtureDef.friction = defFix.friction;
	  fixtureDef.restitution = defFix.restitution;
	  fixtureDef.isSensor = defFix.sensor;

	  //TODO: Do not set filter bits like this. The bodies will not collide.
	  // fixtureDef.filter.categoryBits = defFix.categoryBits;
	  // fixtureDef.filter.maskBits = defFix.maskBits;
	  // fixtureDef.filter.groupIndex = defFix.groupIndex;

	  return fixtureDef;
	}
}

